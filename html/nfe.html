<!DOCTYPE html>
<html>
<head>
<title>nfe  --  Non-deterministic finite automata expression </title>
<meta name='generator' content='fsdocgen'>
<link rel='stylesheet' href='style.css'>
</head>
<body>
<h2>Module description</h2>
<dl><dt>nfe  --  Non-deterministic finite automata expression </dt>
<dd>
The nfe module implements an expression in a non-deterministic finite      
automata. An expression is a concatenation, repetition or alteration of    
non-deterministic finite automata states <a href='nfs.html'>nfs</a>. An    
not yet fully built expression consists of two cells on the stack: a list  
with the non resolved out states and a list of <a href='nfs.html'>nfs</a>  
states.<br>                                                                
The code is based on the Thompson NFA algorithm published by Russ Cox.     
</dd>
</dl>
<hr>
<h2>Expression structure </h2>
<dl>
<dt id='nfe%'>nfe% (  -- n  )</dt>
<dd> Get the required space for a nfe expression </dd>
</dl>
<h2>Expression creation, initialisation and cleanup </h2>
<dl>
<dt id='nfe-init'>nfe-init (  nfe --  )</dt>
<dd> Initialise the expression </dd>
</dl>
<dl>
<dt id='nfe+free-expression'>nfe+free-expression (  nfe --  )</dt>
<dd> Free all states in the [sub]expression [recursive] </dd>
</dl>
<dl>
<dt id='nfe-(free)'>nfe-(free) (  nfe --  )</dt>
<dd> Free the internal, private variables from the heap </dd>
</dl>
<dl>
<dt id='nfe-create'>nfe-create (  "&lt;spaces&gt;name" -- ; -- nfe  )</dt>
<dd> Create a named expression in the dictionary </dd>
</dl>
<dl>
<dt id='nfe-new'>nfe-new (  -- nfe  )</dt>
<dd> Create a new expression on the heap </dd>
</dl>
<dl>
<dt id='nfe-free'>nfe-free (  nfe --  )</dt>
<dd> Free the expression from the heap </dd>
</dl>
<h2>Member words </h2>
<dl>
<dt id='nfe-visit++'>nfe-visit++ (  nfe -- n  )</dt>
<dd> Increment the visit number in the expression, return the visit number </dd>
</dl>
<dl>
<dt id='nfe-level+@'>nfe-level+@ (  nfe -- n  )</dt>
<dd> Increment and return the paren level </dd>
</dl>
<dl>
<dt id='nfe-visit@'>nfe-visit@ (  nfe -- n  )</dt>
<dd> Get the current visit number </dd>
</dl>
<dl>
<dt id='nfe-expression@'>nfe-expression@ (  nfe -- a-addr  )</dt>
<dd> Get the list of states in the expression or nil </dd>
</dl>
<dl>
<dt id='nfe-states@'>nfe-states@ (  nfe -- n  )</dt>
<dd> Get the number of states in the expression </dd>
</dl>
<dl>
<dt id='nfe-parens@'>nfe-parens@ (  nfe -- n  )</dt>
<dd> Get the number of parens in the expression </dd>
</dl>
<h2>Expression building words </h2>
<dl>
<dt id='nfe-clear'>nfe-clear (  nfe --  )</dt>
<dd> Clear the expression </dd>
</dl>
<dl>
<dt id='nfe-single'>nfe-single (  x n nfe -- nfs1 nfs2  )</dt>
<dd> Start an expression, nfs2 nfs1, with a single new state nfs1 with data x and type n </dd>
</dl>
<dl>
<dt id='nfe-concat'>nfe-concat (  nfs1 nfs2 nfs3 nfs4 nfe -- nfs5 nfs6  )</dt>
<dd> Concat the two expressions, return the outs nfs5 and start nfs6 </dd>
</dl>
<dl>
<dt id='nfe-paren'>nfe-paren (  nfs1 nfs2 n nfe -- nfs3 nfs4  )</dt>
<dd> Paren the expression with level n, return the new outs nf3 and start nfs4 </dd>
</dl>
<dl>
<dt id='nfe-alternation'>nfe-alternation (  nfs1 nfs2 nfs3 nfs4 nfe -- nfs5 nfs6  )</dt>
<dd> Make an alternation [|] of two expressions, return the new outs nfs5 and start nfs6 </dd>
</dl>
<dl>
<dt id='nfe-zero-or-one'>nfe-zero-or-one (  nfs1 nfs2 nfe -- nfs3 nfs4  )</dt>
<dd> Repeat the expression one or zero [?] times, return the new start outs nfs3 and start nfs4 </dd>
</dl>
<dl>
<dt id='nfe-zero-or-more'>nfe-zero-or-more (  nfs1 nfs2 nfe -- nfs3 nfs4  )</dt>
<dd> Repeat the expression zero or more [*] times, return the new outs nfs3 and start nfs4 </dd>
</dl>
<dl>
<dt id='nfe-one-or-more'>nfe-one-or-more (  nfs1 nfs2 nfe -- nfs3 nfs4  )</dt>
<dd> Repeat the expression one or more [+] times, return the new outs nfs3 and start nfs4 </dd>
</dl>
<dl>
<dt id='nfe-close'>nfe-close (  nfs1 nfs2 nfe -- nfs3  )</dt>
<dd> Close the expression by adding the match state, return the start nfs3 </dd>
</dl>
<h2>Matching words </h2>
<dl>
<dt id='nfe-match?'>nfe-match? (  c-addr u flag nfe -- flag  )</dt>
<dd> Match a string c-addr u, with the flag indicating case insensitive match, return the match result </dd>
</dl>
<dl>
<dt id='nfe-search'>nfe-search (  c-addr u flag nfe -- n  )</dt>
<dd> Search in the string c-addr u for a match, with the flag indicating case insensitive match, return the first offset for a match, or -1 for no match </dd>
</dl>
<dl>
<dt id='nfe-result'>nfe-result (  n1 nfe -- n2 n3  )</dt>
<dd> Get the match result of the n1th grouping, return match start n3 and end n2 </dd>
</dl>
<h2>Inspection </h2>
<dl>
<dt id='nfe-dump'>nfe-dump (  nfe --  )</dt>
<dd> Dump the expression </dd>
</dl>
<hr>
<p>Generated by fsdocgen 0.1.0</p>
</body>
</html>
