<!DOCTYPE html>
<html>
<head>
<title>snl  --  Generic Single Linked List </title>
<meta name='generator' content='fsdocgen'>
<link rel='stylesheet' href='style.css'>
</head>
<body>
<h2>Module description</h2>
<dl><dt>snl  --  Generic Single Linked List </dt>
<dd>
The snl module implements a single linked list that can store variable size  
nodes. It is the base module for more specialized modules, for example the   
single linked cell list <a href='scl.html'>scl</a> module.                   
</dd>
</dl>
<hr>
<h2>List structure </h2>
<dl>
<dt id='snl%'>snl% (  -- n  )</dt>
<dd> Get the required space for a snl variable </dd>
</dl>
<h2>List creation, initialisation and destruction </h2>
<dl>
<dt id='snl-init'>snl-init (  snl --  )</dt>
<dd> Initialise the snl list </dd>
</dl>
<dl>
<dt id='snl-(free)'>snl-(free) (  xt scl --  )</dt>
<dd> Free the nodes from the heap using xt </dd>
</dl>
<dl>
<dt id='snl-create'>snl-create (  "&lt;spaces&gt;name" -- ; -- snl  )</dt>
<dd> Create a named snl list in the dictionary </dd>
</dl>
<dl>
<dt id='snl-new'>snl-new (  -- snl  )</dt>
<dd> Create a new snl list on the heap </dd>
</dl>
<dl>
<dt id='snl-free'>snl-free (  snl --  )</dt>
<dd> Free the list from the heap </dd>
</dl>
<h2>Member words </h2>
<dl>
<dt id='snl-length@'>snl-length@ (  snl -- u  )</dt>
<dd> Get the number of nodes in the list </dd>
</dl>
<dl>
<dt id='snl-empty?'>snl-empty? (  snl -- flag  )</dt>
<dd> Check for an empty list </dd>
</dl>
<dl>
<dt id='snl-first@'>snl-first@ (  snl -- snn | nil   )</dt>
<dd> Get the first node from the list </dd>
</dl>
<dl>
<dt id='snl-last@'>snl-last@ (  snl -- snn | nil  )</dt>
<dd> Get the last node from the list </dd>
</dl>
<h2>List words </h2>
<dl>
<dt id='snl-append'>snl-append (  snn snl --  )</dt>
<dd> Append the node snn to the list </dd>
</dl>
<dl>
<dt id='snl-prepend'>snl-prepend (  snn snl --  )</dt>
<dd> Prepend the node snn in the list </dd>
</dl>
<dl>
<dt id='snl-insert-after'>snl-insert-after (  snn1 snn2 snl --  )</dt>
<dd> Insert the node snn1 after the reference node snn2 in the list </dd>
</dl>
<dl>
<dt id='snl-remove-first'>snl-remove-first (  snl -- snn | nil  )</dt>
<dd> Remove the first node from the list, return the removed node </dd>
</dl>
<dl>
<dt id='snl-remove-after'>snl-remove-after (  snn1 snl -- snn2 | nil  )</dt>
<dd> Remove the node after the reference node snn1 from the list, return the removed node </dd>
</dl>
<h2>Index words </h2>
<dl>
<dt id='snl-index?'>snl-index? (  n snl -- flag  )</dt>
<dd> Check if the index n is valid in the list </dd>
</dl>
<dl>
<dt id='snl-get'>snl-get (  n snl -- snn  )</dt>
<dd> Get the nth node from the list </dd>
</dl>
<dl>
<dt id='snl-insert'>snl-insert (  snn n snl --  )</dt>
<dd> Insert a node before the nth node in the list </dd>
</dl>
<dl>
<dt id='snl-delete'>snl-delete (  n snl -- snn  )</dt>
<dd> Delete the nth node from the list, return the deleted node </dd>
</dl>
<h2>LIFO words </h2>
<dl>
<dt id='snl-push'>snl-push (  snn snl --  )</dt>
<dd> Push the node snn at the top of the stack [= start of the list] </dd>
</dl>
<dl>
<dt id='snl-pop'>snl-pop (  snl -- snn | nil  )</dt>
<dd> Pop the node at the top of the stack [= start of the list], return the popped node </dd>
</dl>
<dl>
<dt id='snl-tos'>snl-tos (  snl -- snn | nil  )</dt>
<dd> Get the node at the top of the stack [= start of the list], return this node </dd>
</dl>
<h2>FIFO words </h2>
<dl>
<dt id='snl-enqueue'>snl-enqueue (  snn snl --  )</dt>
<dd> Enqueue the node snn at the start of the queue [=end of the list] </dd>
</dl>
<dl>
<dt id='snl-dequeue'>snl-dequeue (  snl -- snn | nil  )</dt>
<dd> Dequeue the node at the end of the queue [= start of the list], return this node </dd>
</dl>
<h2>Special words </h2>
<dl>
<dt id='snl-execute'>snl-execute (  i*x xt snl -- j*x  )</dt>
<dd> Execute xt for every node in list </dd>
</dl>
<dl>
<dt id='snl-execute?'>snl-execute? (  i*x xt snl -- j*x flag  )</dt>
<dd> Execute xt for every node in the list or until xt returns true, flag is true if xt returned true </dd>
</dl>
<dl>
<dt id='snl-reverse'>snl-reverse (  snl --  )</dt>
<dd> Reverse or mirror the list </dd>
</dl>
<h2>Sort word </h2>
<dl>
<dt id='snl-sort'>snl-sort (  xt snl --  )</dt>
<dd> Sort the list snl using mergesort, xt compares the nodes </dd>
</dl>
<h2>Inspection </h2>
<dl>
<dt id='snl-dump'>snl-dump (  snl --  )</dt>
<dd> Dump the list </dd>
</dl>
<h2>Examples</h2>
<pre>
\ ==============================================================================
\
\          snl_expl - the single linked list example in the ffl
\
\               Copyright (C) 2010  Dick van Oudheusden
\  
\ This library is free software; you can redistribute it and/or
\ modify it under the terms of the GNU General Public
\ License as published by the Free Software Foundation; either
\ version 2 of the License, or (at your option) any later version.
\
\ This library is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\ General Public License for more details.
\
\ You should have received a copy of the GNU General Public
\ License along with this library; if not, write to the Free
\ Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
\
\ ==============================================================================
\ 
\  $Date: 2008-04-10 16:12:01 $ $Revision: 1.1 $
\
\ ==============================================================================

include ffl/snl.fs
include ffl/rng.fs


\ Example: sort a single linked list with 1001 random floats


\ Create the single linked list on the heap

snl-new value flist

\ Extend the generic single linked list node with a float field

begin-structure fnode%
  snn%
  +field   fnode&gt;node
  ffield:  fnode&gt;float
end-structure

\ Create the pseudo random generator in the dictionary with seed 5489

5489 rng-create frng

\ Insert 1001 float nodes in the flist

: flist-insert     ( n -- = Insert n random floats in flist )
  0 DO
    frng rng-next-float           \ Generate random float
    fnode% allocate throw         \ Allocate fnode
    dup fnode&gt;node  snn-init      \ Initialise generic node
    dup fnode&gt;float f!            \ Store random float
        flist snl-append          \ Append to flist
  LOOP
;

1001 flist-insert

\ Check the number of floats out of sequence

: fnode-out-sequence ( n1 r1 fnode -- n2 r2 = Count the number of out of sequence floats, n: count r:previous float )
  fnode&gt;float f@
  fswap fover
  f&gt; IF 1+ THEN                   \ Compare current float with previous float, increment counter if out of sequence
;

.( Before sorting there are ) 0 -1.0E+0 &apos; fnode-out-sequence flist snl-execute fdrop . .( floats out of sequence. ) cr

\ Sort the list using the fnode-compare word

: fnode-compare    ( fnode1 fnode2 -- n = Compare fnode1 with fnode2 )
  swap fnode&gt;float f@ fnode&gt;float f@ f-
  fdup f0&lt; IF
    fdrop -1
  ELSE f0= IF
    0
  ELSE
    1
  THEN THEN
;

&apos; fnode-compare flist snl-sort

\ Check the number of floats out of sequence again

.( After sorting there are ) 0 -1.0E+0 &apos; fnode-out-sequence flist snl-execute fdrop . .( floats out of sequence. ) cr

\ Cleanup the list

flist snl-free                    \ No dynamic memory stored in node, so default free word can be used

</pre>
<hr>
<p>Generated by fsdocgen 0.1.0</p>
</body>
</html>
